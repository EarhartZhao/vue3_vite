import { BuildConfig } from 'vite'

export const build_config = {
  entry: "index.html",
  base: "/",
  outDir: "dist",
  assetsDir: "_assets",
  assetsInlineLimit: 200,
  cssCodeSplit: true,
  sourcemap: true,
  minify: "terser",
  terserOptions: {},
  // esbuildTarget:'',
  ssr: false,
  rollupOptions: {},
  // rollupInputOptions: {
  //   external: ["fs", "child_process", "vuex-class", "vuex"],
  // },

  /**
   * Entry. Use this to specify a js entry file in use cases where an
   * `index.html` does not exist (e.g. serving vite assets from a different host)
   * @default 'index.html'
   */
  // entry: string
  /**
   * Base public path when served in production.
   * @default '/'
   */
  // base: string
  /**
   * Directory relative from `root` where build output will be placed. If the
   * directory exists, it will be removed before the build.
   * @default 'dist'
   */
  // outDir: string
  /**
   * Directory relative from `outDir` where the built js/css/image assets will
   * be placed.
   * @default '_assets'
   */
  // assetsDir: string
  /**
   * Static asset files smaller than this number (in bytes) will be inlined as
   * base64 strings. Default limit is `4096` (4kb). Set to `0` to disable.
   * @default 4096
   */
  // assetsInlineLimit: number
  /**
   * Whether to code-split CSS. When enabled, CSS in async chunks will be
   * inlined as strings in the chunk and inserted via dynamically created
   * style tags when the chunk is loaded.
   * @default true
   */
  // cssCodeSplit: boolean
  /**
   * Whether to generate sourcemap
   * @default false
   */
  // sourcemap: boolean | 'inline'
  /**
   * Set to `false` to disable minification, or specify the minifier to use.
   * Available options are 'terser' or 'esbuild'.
   * @default 'terser'
   */
  // minify: boolean | 'terser' | 'esbuild'
  /**
   * The option for `terser`
   */
  // terserOptions: RollupTerserOptions
  /**
   * Transpile target for esbuild.
   * @default 'es2020'
   */
  // esbuildTarget: string
  /**
   * Build for server-side rendering, only as a CLI flag
   * for programmatic usage, use `ssrBuild` directly.
   * @internal
   */
  // ssr?: boolean

  // The following are API / config only and not documented in the CLI. --------
  /**
   * Will be passed to rollup-plugin-vue
   *
   * https://github.com/vuejs/rollup-plugin-vue/blob/next/src/index.ts
   */
  // rollupPluginVueOptions: Partial<RollupPluginVueOptions>
  /**
   * Will be passed to @rollup/plugin-node-resolve
   * https://github.com/rollup/plugins/tree/master/packages/node-resolve#dedupe
   */
  // rollupDedupe: string[]
  /**
   * Whether to log asset info to console
   * @default false
   */
  // silent: boolean
  /**
   * Whether to write bundle to disk
   * @default true
   */
  // write: boolean
  /**
   * Whether to emit index.html
   * @default true
   */
  // emitIndex: boolean
  /**
   * Whether to emit assets other than JavaScript
   * @default true
   */
  // emitAssets: boolean
  /**
   * Whether to emit a manifest.json under assets dir to map hash-less filenames
   * to their hashed versions. Useful when you want to generate your own HTML
   * instead of using the one generated by Vite.
   *
   * Example:
   *
   * ```json
   * {
   *   "main.js": "main.68fe3fad.js",
   *   "style.css": "style.e6b63442.css"
   * }
   * ```
   * @default false
   */
  // emitManifest?: boolean
  /**
   * Predicate function that determines whether a link rel=modulepreload shall be
   * added to the index.html for the chunk passed in
   */
  // shouldPreload: ((chunk: OutputChunk) => boolean) | null
  /**
   * Enable 'rollup-plugin-vue'
   * @default true
   */
  // enableRollupPluginVue?: boolean
  /**
   * Plugin functions that mutate the Vite build config. The `builds` array can
   * be added to if the plugin wants to add another Rollup build that Vite writes
   * to disk. Return a function to gain access to each build's output.
   * @internal
   */
  // configureBuild?: BuildPlugin | BuildPlugin[]
};
