{
  "resource_name": {
    "prefix": "name",
    "body": [
      "const idPattern = `[\\w-]{6,256}`",
      "",
      "var idRE = regexp.MustCompile(fmt.Sprintf(\"^%s$\", idPattern))",
      "",
      "// CheckID checks the id whether is a valid ${2:resource} id.",
      "func CheckID(id string) error {",
      "\tif idRE.MatchString(id) {",
      "\t\treturn nil",
      "\t}",
      "\treturn fmt.Errorf(\"invalid ${2:resource} id: %q not match %q\", id, idPattern)",
      "}",
      "",
      "// FullName returns a full ${2:resource} name by ${1:parent} name and ${2:resource} id.",
      "func FullName(${1:parent}, id string) string {",
      "\treturn path.Join(${1:parent}, \"${2:resource}s\", id)",
      "}",
      "",
      "var nameRE = regexp.MustCompile(`^(${1:parent}s/[^/]+)/${2:resource}s/([^/]+)`)",
      "",
      "// ParseName parses a ${2:resource} name to ${1:parent} name and ${2:resource} ID. When parse",
      "// ${2:resource} name, do not validate the ${2:resource} ID.",
      "func ParseName(name string) (${1:parent}, id string, err error) {",
      "\tm := nameRE.FindStringSubmatch(name)",
      "\tif m == nil {",
      "\t\treturn \"\", \"\", fmt.Errorf(\"invalid ${2:resource} name: %q not match %v\", name, nameRE)",
      "\t}",
      "\treturn m[1], m[2], nil",
      "}"
    ]
  },
  "resource_buffered_store": {
    "prefix": "store",
    "body": [
      "type resourceInitializer struct{}",
      "",
      "func (resourceInitializer) FromRow(r *rtable.Row) (resource.Resource, error) {",
      "\tvar ${1/.*?(\\w+)$/${1:/downcase}/} ${1:pb.Resource}",
      "\tif err := db.Unmarshal(r.Resource, &${1/.*?(\\w+)$/${1:/downcase}/}); err != nil {",
      "\t\treturn nil, err",
      "\t}",
      "\t${2:${1/.*?(\\w+)$/${1:/downcase}/}.CreateTime, _ = ptypes.TimestampProto(r.CreateTime)",
      "\t${1/.*?(\\w+)$/${1:/downcase}/}.UpdateTime, _ = ptypes.TimestampProto(r.UpdateTime)}",
      "\treturn &${1/.*?(\\w+)$/${1:/downcase}/}, nil",
      "}",
      "",
      "func mutationFromChange(chg *resource.Change) (*spanner.Mutation, error) {",
      "\t${3:if chg.IsCreate() {",
      "\t\treturn rtable.Insert(ddl.Table, chg.New)",
      "\t\\}",
      "\tif chg.IsDelete() {",
      "\t\treturn rtable.Purge(ddl.Table, chg.Old)",
      "\t\\}",
      "\treturn rtable.Update(ddl.Table, chg.New)}",
      "}",
      "",
      "// BufferedStore wraps a resource.BufferedStore to provide typed methods.",
      "type BufferedStore struct {",
      "\t*resource.BufferedStore",
      "}",
      "",
      "// NewBufferedStore returns a ProductBufferedStore based on a resource table.",
      "func NewBufferedStore(ctx context.Context, tx rtable.ReadTransaction) *BufferedStore {",
      "\treturn &BufferedStore{",
      "\t\tresource.NewBufferedStore(rtable.NewSnapshotStore(ctx, tx, ddl.Table, resourceInitializer{})),",
      "\t}",
      "}",
      "",
      "// Get returns a ${1:pb.Resource} by a given name.",
      "func (bs *BufferedStore) Get(name string) (*${1:pb.Resource}, error) {",
      "\tm, err := bs.BufferedStore.Get(name)",
      "\tif err != nil {",
      "\t\treturn nil, err",
      "\t}",
      "\treturn m.(*${1:pb.Resource}), nil",
      "}",
      "",
      "// Create creates a ${1:pb.Resource} in buffered store.",
      "func (bs *BufferedStore) Create(p *${1:pb.Resource}) (*${1:pb.Resource}, error) {",
      "\tm, err := bs.BufferedStore.Create(p)",
      "\tif err != nil {",
      "\t\treturn nil, err",
      "\t}",
      "\treturn m.(*${1:pb.Resource}), nil",
      "}",
      "",
      "// Ensure ensures a ${1:pb.Resource} existed in buffered store.",
      "func (bs *BufferedStore) Ensure(p *${1:pb.Resource}) (*${1:pb.Resource}, error) {",
      "\tm, err := bs.BufferedStore.Ensure(p)",
      "\tif err != nil {",
      "\t\treturn nil, err",
      "\t}",
      "\treturn m.(*${1:pb.Resource}), nil",
      "}",
      "",
      "// BatchGet batch gets ${1:pb.Resource}s by the given names.",
      "func (bs *BufferedStore) BatchGet(names []string) (map[string]*${1:pb.Resource}, error) {",
      "\tm, err := bs.BufferedStore.BatchGet(names)",
      "\tif err != nil {",
      "\t\treturn nil, err",
      "\t}",
      "\tvar sm = make(map[string]*${1:pb.Resource}, len(m))",
      "\tfor n, r := range m {",
      "\t\tsm[n] = r.(*${1:pb.Resource})",
      "\t}",
      "\treturn sm, nil",
      "}",
      "",
      "// Mutations returns mutations based on the changes.",
      "func (bs *BufferedStore) Mutations() ([]*spanner.Mutation, error) {",
      "\treturn db.MutationsFromChanges(bs.Changes(), mutationFromChange)",
      "}"
    ]
  },
  "db_procedure": {
    "prefix": "procedure",
    "body": [
      "type ${1:Proc} struct {",
      "\t${2:Attributes}",
      "}",
      "",
      "func (proc *${1:Proc}) Reset(ctx context.Context, tx *spanner.ReadWriteTransaction) error {",
      "\t${3:Placeholder}",
      "}",
      "",
      "func (proc *${1:Proc}) Commit(tx *spanner.ReadWriteTransaction) error {",
      "\t${4:Placeholder}",
      "}",
      "",
      "func (proc *${1:Proc}) Do() error {",
      "\t${5:Placeholder}",
      "}"
    ]
  }
}
